# [Chapter 01] 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

> 1부를 학습하면, **람다 표현식**이 무엇인지 확실하게 이해할 수 있고, 바뀌는 요구사항에 쉽게 대응할 수 있도록 **유연하면서도 간결한 코드**를 구현할 수 있는 능력을 갖게 될 것이다.
> 

# 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

자바는 새로운 기능과 더불어 계속 발전했다. 자바의 변화를 우리가 눈여겨 봐야 하는 이유는 무엇인가.

# 1.1 역사의 흐름은 무엇인가?

자바 역사를 통틀어 가장 큰 변화는 자바 8에서 일어났다.

### 간결한 코드

다음과 같은 고전적 코드는

```java
Collections.sort(inventory, new Comparator<Apple>() {
      public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
      }
});
```

자바 8에서는 다음처럼 **간결하게 코드를 작성**할 수 있다. (**자연어에 가깝다**)

```java
inventory.sort(comparing(Apple::getWeight));
```

### 멀티코어 프로세서의 쉬운 활용

**멀티코어 CPU 대중화**같은 하드웨어적인 변화도 자바 8에 영향을 미쳤다.

자바 8 이전에는, 대부분의 자바 프로그램은 코어 중 하나만을 사용했다. 나머지 코어를 활용하려면, `스레드`를 사용했다. 하지만, 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다.

자바는 **병렬 실행 환경을 쉽게 관리하고, 에러가 덜 발생하는 방향으로 진화**하려 노력했다.

### 자바 8 에서 제공하는 새로운 기술

- **스트림 API**

**병렬 연산**을 지원하는 `스트림`이라는 새로운 API 를 제공한다. 스트림을 이용하면 `synchronized`(에러도 잦고 비용도 큼)를 사용하지 않아도 된다.

- **메서드에 코드를 전달**

새롭고 간결한 방식으로 `동작 파라미터화`를 구현할 수 있다.

메서드에 코드를 전달하는 기법은 `함수형 프로그래밍` 에서 위력을 발휘한다. 코드를 전달, 조합해서 자바 프로그래밍 도구로 활용할 수 있다.

- 인터페이스의 디폴트 메서드

# 1.2 왜 아직도 자바는 변화하는가?

자바는 커다란 생태계를 성공적으로 구축했다. 자바는 어떻게 성공을 거둘 수 있었는가.

- 프로그래밍 언어 생태계에서 자바의 위치
    - 자바는 잘 설계된 객체지향 언어로 시작
    - 처음부터 스레드와 락을 이용한 소소한 동시성도 지원
    - 코드를 JVM 바이트 코드로 컴파일하는 특징 → 인터넷 애플릿 프로그램의 주요 언어
    
    <aside>
    💡 **자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가?**
    1. 캡슐화 덕분에 C 에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다.
    2. 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다.
    
    일단 만들면 모든 곳에서 실행할 수 있었다. 안전하게 자바를 실행할 수 있었던 초기 브라우저 덕분에, 자바는 대중화될 수 있었다. 처음에는 C/C++에 비해 시간이 오래 걸려 반감이 있었으나, 하드웨어가 발전하면서 프로그래머의 시간이 더욱 중요한 요소로 부각되었다.
    
    </aside>
    
- 프로그래밍 언어 생태계에 분 변화의 바람
    - 빅데이터를 효과적으로 처리할 필요성(**병렬 프로세싱**을 활용해야함)
    - 외부에서 큰 하위시스템 컴포넌트 추가, 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례 증가 → 이로 인해 자바 8,9에서는 디폴트 메서드와 모듈을 제공함

## 1.2.2 스트림 처리

### 스트림이란?

한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.

다음 예제를 보자. 스트림과 관련된 유닉스 명령이다.

```
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```

유닉스 명령행에서는 파이프(|) 를 이용해서 명령을 연결할 수 있다. 유닉스에서는 여러 명령을 병렬로 실행한다. 이와 같이, **스트림 API는 파이프라인을 만드는데 필요한 많은 메서드를 제공**한다.

### 스트림 핵심

기존에는 한 번에 한 항목을 처리했지만, 이제는 마치 데이터베이스 질의처럼, 고수준으로 추상화해서, 일련의 스트림으로 만들어 처리하자는 것이다. 스트림 파이프라인을 이용해, 입력 부분을 **여러 CPU 코어에 쉽게 할당**할 수 있다. 스레드라는 복잡한 작업을 사용하지 않으면서도, 공짜로 **병렬성**을 얻을 수 있다.

## 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

### 자바 8 이전에는 메서드를 다른 메서드로 전달할 방법이 없었다.

1장의 고전 코드 예제 처럼 Comparator 객체를 만들어, sort에 넘겨주는 방법도 있지만 이는 복잡하며, 기존 코드를 단순 재활용하고 있다.

### 동작 파라미터화 맛보기

![Untitled](https://user-images.githubusercontent.com/92802207/209967905-8d23220d-74c7-4435-aca0-506563876533.png)

compareUsingCustomerId 메서드(**sort의 동작을 파라미터화 할 수 있는 코드**)를 전달하고 있다.

## 1.2.4 병렬성과 공유 가변 데이터

### 공짜는 없을 텐데? 병렬성을 얻는 대신 포기해야 하는 것은 무엇인가.

스트림 메서드로 전달하는 코드의 **동작 방식**을 바꿔야 한다. 

스트림 메서드로 전달하는 코드는, 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 그러려면, 공유된 가변 데이터에 접근하지 않아야 한다. `synchronized`를 이용해서 공유된 가변 데이터를 보호할 수 있지만, 이는 시스템 성능에 악영향을 미친다.

## 1.2.5 자바가 진화해야 하는 이유

고전적인 객체지향에서 벗어나 **함수형 프로그래밍으로 다가섰다**는 것이 자바 8의 가장 큰 변화이다. 함수형 프로그래밍에서는 **우리가 하려는 작업**이 최우선시되고, 그 작업을 어떻게 수행하는지는 별개의 문제로 취급한다.

언어는 하드웨어나, 프로그래머 기대의 변화에 부응하는 방향으로 진화해야 한다.

# 1.3 자바 함수

프로그래밍 언어에서 함수는, 메서드(특히 정적 메서드)와 같은 의미로 사용된다. 자바의 함수는 이에 더해, **수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수**를 의미한다.

### 자바 8에서 함수를 새로운 값의 형식으로 추가한 이유는?

멀티코어에서 `병렬 프로그래밍`을 활용할 수 있는 `스트림`과 연계될 수 있도록 함수를 만들었기 때문이다.

### 자바에서 함수는 왜 필요한가?

`int`, `double`, `인스턴스` 모두 값이다. new 또는, 팩토리 메서드 등을 사용해서 객체의 값을 얻을 수 있고, 객체 참조를 얻을 수 있다. 그렇다면 함수는 왜 필요한가.

프로그래밍 언어의 핵심은 **값을 바꾸는 것**이다. **위에서 언급한 값들은 일급 자바 시민(전달할 수 있는 구조체)이지만 메서드, 클래스는 이급 시민(전달할 수 없는 구조체)이다.** 여전히 메서드와 클래스는 그 자체로 값이 될 수 없다는 것이다. 이급 시민을 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다. 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.

## 1.3.1 메서드와 람다를 일급 시민으로

### 메서드 참조

`File` 클래스는 `isHidden` 메서드를 제공한다. 다음 예제를 보자.

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() { // FileFilter로 감싸고, 전달
      @Override
      public boolean accept(File file) {
        return file.isHidden(); // isHidden의 결과를 File.listFiles 메서드로 전달
      }
});
```

굳이 `FileFilter`로 isHidden 을 복잡하게 감싼 다음에 FileFilter를 인스턴스화 해야 할까?

자바 8에서는 아주 멋지고 간결하게 코드를 작성할 수 있다.

```java
File[] hiddenFiles2 = new File(".").listFiles(File::isHidden);
```

> 너무 멋있다 … !
> 

이미 `isHidden` 이라는 **함수**는 준비되어 있으므로, **메서드 참조 ::** (이 메서드를 값으로 사용하라!)를 이용해서 직접 listFiles에 전달할 수 있다.

코드가 짧아졌음에도, 기존에 비해서 문제 자체를 더 직접적으로 설명하고 있다.

## 1.3.2 코드 넘겨주기 : 예제

```java
// main
	List<Apple> inventory = new ArrayList<>();
	filterApples(inventory, Apple::isGreenApple);
	filterApples(inventory, (Apple a) -> a.getWeight() > 150);
	filterApples(inventory, Apple::isHeavyApple);
}

public interface Predicate<T>{
    boolean test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p){
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory){
        if (p.test(apple)){
            result.add(apple);
        }
    }
    return result;
}
```

### Predicate 란?

인수로 값을 받아서 `true`, `false` 를 반환하는 인터페이스

## 1.3.3. 메서드에서 람다로

한 번만 사용할 메서드를 따로 구현할 필요가 있을까? 자바 8에서는, 익명함수 또는 람다라는 새로운 개념을 이용해서 코드를 짧고 간결하게 구현할 수 있다.

하지만, 람다가 몇 줄 이상 길어진다면, 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하는 것이 바람직하다. 항상 코드의 명확성을 우선시하자.

# 1.4 스트림

스트림 API를 이용하면 복잡한 필터링, 그룹화를 간결한 코드로 구현할 수 있다.

```java
List<Transaction> transactions = new ArrayList<>();
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream()
                .filter((Transaction t) -> t.getPrice() > 1000)
                .collect(groupingBy(Transaction::getCurrency));
```

### 컬렉션 API 와 스트림 API 의 차이?

컬렉션

- 외부 반복
    - for-each 루프를 이용해서 각 요소를 반복
- 어떻게 데이터를 저장하고, 접근할 지 중점을 둠

스트림

- 내부 반복
    - 라이브러리 내부에서 모든 데이터가 처리됨
- 어떤 계산을 할 것인지 묘사하는 것에 중점을 둠

### 1.4.1 멀티스레딩은 어렵다

이전 자바버전에서 제공하는 스레드 API로 멀티스레딩을 구현하고, 병렬성을 이용하는 것은 쉽지 않다.

멀티스레딩 환경에서, **동시에 공유된 데이터에 접근**하고, 데이터를 갱신할 수 있으므로 데이터의 값이 원치 않는 방식으로 바뀔 수 있다는 것.

이는 스트림 API 로 넘어오면서 해결할 수 있다. 아래는 대략적인 스트림 API의 처리 과정이다.

![Untitled1](https://user-images.githubusercontent.com/92802207/209968068-eb817189-f33a-43d7-9d57-d97d341c4e56.png)

1. 포킹 단계
    
    한 CPU는 리스트의 앞부분을, 나머지는 뒷부분을 처리하도록 요청한다.
    
2. 처리
3. 조인 단계

### 스트림과 람다 표현식을 이용한 필터링 예제

```java
// 순차 처리 방식의 코드
List<Apple> heavyApples1 = inventory.stream() // 컬렉션을 스트림으로 변환
              .filter((Apple a) -> a.getWeight() > 150) // 병렬로 처리
      .collect(toList()); // 리스트로 다시 복원
// 병렬 처리 방식의 코드
List<Apple> heavyApples2 = inventory.parallelStream() // 컬렉션을 스트림으로 변환
              .filter((Apple a) -> a.getWeight() > 150) // 병렬로 처리
       .collect(toList()); // 리스트로 다시 복원
```

# 1.5 디폴트 메서드와 자바 모듈

요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다. 자바 8 이전에는, 이와 관련해서 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였다. 이런 패키지의 인터페이스를 바꿔야 하는 상황이 오면, 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 했다…(정말 고통스러웠을 듯)

1. 자바 9의 모듈 시스템
    - 모듈을 정의하는 문법 제공
    - 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다.
2. 디폴트 메서드 지원
    - 인터페이스를 쉽게 바꿀 수 있게 되었다.

예를 들어, 자바 8에서는 List에 직접 sort 메서드를 호출 할 수 있다. List 인터페이스에 다음의 디폴트 메서드 정의가 추가되었기 때문이다.

```java
default void sort(Comparator<? super E> c){
	Collections.sort(this, c);
}
```

따라서 자바 8 부터는 디폴트 sort를 구현할 필요가 없다.

# 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

### Optional<T> 클래스 - NullPointer 예외를 피할 수 있도록 도와주는 클래스

- 값을 갖거나, 갖지 않을 수 있는 컨테이너 객체이다.
- 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다.
- NullPointer 예외를 피할 수 있다.
